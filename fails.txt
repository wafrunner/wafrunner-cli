============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/sam/Engineering/wafrunner/wafrunner-cli
configfile: pyproject.toml
plugins: anyio-4.9.0, mock-3.14.1, cov-6.2.1
collected 59 items

tests/test_api_client.py .........                                       [ 15%]
tests/test_collection_commands.py .....F...                              [ 30%]
tests/test_config_manager.py ..                                          [ 33%]
tests/test_cve_download_range.py .........                               [ 49%]
tests/test_cve_download_update.py FFF.....FF.                            [ 67%]
tests/test_cve_upload_tracking.py .......FF                              [ 83%]
tests/test_research_commands.py FFFFF                                    [ 91%]
tests/test_shell_command.py .....                                        [100%]

=================================== FAILURES ===================================
_____________________________ test_collection_list _____________________________

data_dir = PosixPath('/tmp/pytest-of-sam/pytest-61/test_collection_list0/.wafrunner/data')

    def test_collection_list(data_dir):
        """Tests the list command output."""
        create_mock_collection_file(data_dir, "coll-1", {"name": "coll-1", "vulnerabilities": [1,2,3], "keywords": ["kw1"], "last_updated": "date1"})
        create_mock_collection_file(data_dir, "coll-2", {"name": "coll-2", "vulnerabilities": [1], "keywords": ["kw2"], "last_updated": "date2"})
    
        result = runner.invoke(collection_app.app, ["list"])
    
        assert result.exit_code == 0
        assert "coll-1" in result.stdout
        assert "coll-2" in result.stdout
>       assert "3" in result.stdout # item count
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert '3' in '                             Available Collections                              \n┏━━━━━━━━┳━━━━━━━┳━━━━━━━━━━┳━━━━━━...       │ is not a dictionary.    │\n└────────┴───────┴──────────┴────────────────────────┴─────────────────────────┘\n'
E        +  where '                             Available Collections                              \n┏━━━━━━━━┳━━━━━━━┳━━━━━━━━━━┳━━━━━━...       │ is not a dictionary.    │\n└────────┴───────┴──────────┴────────────────────────┴─────────────────────────┘\n' = <Result okay>.stdout

tests/test_collection_commands.py:164: AssertionError
__________________ test_download_no_update_file_exists_valid ___________________

mock_path_methods = (<MagicMock name='exists' id='127019398780576'>, <MagicMock name='mkdir' id='127019396985824'>)
mock_json_io = (<MagicMock name='load' id='127019397010144'>, <MagicMock name='dump' id='127019397013984'>)
mock_time_sleep = <MagicMock name='sleep' id='127019397041856'>
mock_download_cves_for_range = <MagicMock name='download_cves_for_range' id='127019397045792'>
mock_is_error_file_func = <MagicMock name='is_error_file' id='127019397073520'>
mock_progress = <MagicMock id='127019397074432'>
mock_httpx_client = <MagicMock id='127019396894496'>

    def test_download_no_update_file_exists_valid(
        mock_path_methods, mock_json_io, mock_time_sleep, mock_download_cves_for_range, mock_is_error_file_func, mock_progress, mock_httpx_client
    ):
        """
        Test download command when --update is False, file exists and is valid.
        Should skip download.
        """
        mock_path_methods[0].return_value = True  # Path.exists returns True
        mock_is_error_file_func.return_value = False  # File is not an error file
    
        year = 2023
        result = runner.invoke(cve_app, ["download", "--year", str(year)])
    
        assert result.exit_code == 0
>       assert "already exists and appears valid. Skipping." in result.stdout
E       AssertionError: assert 'already exists and appears valid. Skipping.' in 'Initializing CVE download from 2023 to 2023 from NIST...\nData will be saved to /home/sam/.wafrunner/data/cve-sources...-cves-2023-3.json is valid. Skipping.\nFile nvd-cves-2023-4.json is valid. Skipping.\n\n✔ Download process finished.\n'
E        +  where 'Initializing CVE download from 2023 to 2023 from NIST...\nData will be saved to /home/sam/.wafrunner/data/cve-sources...-cves-2023-3.json is valid. Skipping.\nFile nvd-cves-2023-4.json is valid. Skipping.\n\n✔ Download process finished.\n' = <Result okay>.stdout

tests/test_cve_download_update.py:84: AssertionError
_________________ test_download_no_update_file_exists_invalid __________________

mock_path_methods = (<MagicMock name='exists' id='127019397021664'>, <MagicMock name='mkdir' id='127019398675968'>)
mock_json_io = (<MagicMock name='load' id='127019398920528'>, <MagicMock name='dump' id='127019398917696'>)
mock_time_sleep = <MagicMock name='sleep' id='127019398815456'>
mock_download_cves_for_range = <MagicMock name='download_cves_for_range' id='127019398818672'>
mock_is_error_file_func = <MagicMock name='is_error_file' id='127019400805552'>
mock_progress = <MagicMock id='127019400803680'>
mock_httpx_client = <MagicMock id='127019398874032'>

    def test_download_no_update_file_exists_invalid(
        mock_path_methods, mock_json_io, mock_time_sleep, mock_download_cves_for_range, mock_is_error_file_func, mock_progress, mock_httpx_client
    ):
        """
        Test download command when --update is False, file exists but is invalid.
        Should re-download.
        """
        mock_path_methods[0].return_value = True  # Path.exists returns True
        mock_is_error_file_func.return_value = True  # File is an error file
    
        year = 2023
        result = runner.invoke(cve_app, ["download", "--year", str(year)])
    
        assert result.exit_code == 0
>       assert "exists but is incomplete or has errors." in result.stdout
E       AssertionError: assert 'exists but is incomplete or has errors.' in 'Initializing CVE download from 2023 to 2023 from NIST...\nData will be saved to /home/sam/.wafrunner/data/cve-sources. Update mode: False\n\n✔ Download process finished.\n'
E        +  where 'Initializing CVE download from 2023 to 2023 from NIST...\nData will be saved to /home/sam/.wafrunner/data/cve-sources. Update mode: False\n\n✔ Download process finished.\n' = <Result okay>.stdout

tests/test_cve_download_update.py:102: AssertionError
____________________ test_download_update_file_exists_valid ____________________

mock_path_methods = (<MagicMock name='exists' id='127019398912080'>, <MagicMock name='mkdir' id='127019398709856'>)
mock_json_io = (<MagicMock name='load' id='127019397257296'>, <MagicMock name='dump' id='127019397261136'>)
mock_time_sleep = <MagicMock name='sleep' id='127019397305440'>
mock_download_cves_for_range = <MagicMock name='download_cves_for_range' id='127019397313024'>
mock_is_error_file_func = <MagicMock name='is_error_file' id='127019397271088'>
mock_progress = <MagicMock id='127019397272048'>
mock_httpx_client = <MagicMock id='127019397365840'>

    def test_download_update_file_exists_valid(
        mock_path_methods, mock_json_io, mock_time_sleep, mock_download_cves_for_range, mock_is_error_file_func, mock_progress, mock_httpx_client
    ):
        """
        Test download command when --update is True, file exists and is valid.
        Should re-download.
        """
        mock_path_methods[0].return_value = True  # Path.exists returns True
        mock_is_error_file_func.return_value = False  # File is not an error file (this call still happens but is ignored for decision)
    
        year = 2023
        result = runner.invoke(cve_app, ["download", "--year", str(year), "--update"])
    
        assert result.exit_code == 0
        assert "Data will be saved to" in result.stdout # Initial message
        assert "Update mode: True" in result.stdout
>       assert "re-downloading due to --update flag" in result.stdout # Because update is True
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert 're-downloading due to --update flag' in 'Initializing CVE download from 2023 to 2023 from NIST...\nData will be saved to /home/sam/.wafrunner/data/cve-sources. Update mode: True\n\n✔ Download process finished.\n'
E        +  where 'Initializing CVE download from 2023 to 2023 from NIST...\nData will be saved to /home/sam/.wafrunner/data/cve-sources. Update mode: True\n\n✔ Download process finished.\n' = <Result okay>.stdout

tests/test_cve_download_update.py:124: AssertionError
______________________ test_is_error_file_total_mismatch _______________________

self = <MagicMock name='print' id='127019397526496'>
args = ('[yellow]File mismatch.json has totalResults=10 but contains 1 vulnerabilities. Flagging for re-download.[/yellow]',)
kwargs = {}
expected = call('[yellow]File mismatch.json has totalResults=10 but contains 1 vulnerabilities. Flagging for re-download.[/yellow]')
actual = call('[yellow]File mismatch.json has mismatched counts. Flagging for re-download.[/yellow]')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7386020cdf80>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: print('[yellow]File mismatch.json has totalResults=10 but contains 1 vulnerabilities. Flagging for re-download.[/yellow]')
E             Actual: print('[yellow]File mismatch.json has mismatched counts. Flagging for re-download.[/yellow]')

/usr/lib/python3.12/unittest/mock.py:944: AssertionError

During handling of the above exception, another exception occurred:

mocker = <pytest_mock.plugin.MockerFixture object at 0x73860213de80>

    def test_is_error_file_total_mismatch(mocker):
        """Test is_error_file with totalResults not matching actual vulnerabilities count."""
        mock_open = mocker.patch("builtins.open", mocker.mock_open(read_data=json.dumps({"download_status": "complete", "totalResults": 10, "vulnerabilities": [{"cve": {"id": "CVE-2023-1234"}}]})))
        mock_print = mocker.patch("wafrunner_cli.commands.cve.print")
        assert is_error_file(Path("mismatch.json")) is True
>       mock_print.assert_called_with(
            "[yellow]File mismatch.json has totalResults=10 but contains 1 vulnerabilities. Flagging for re-download.[/yellow]"
        )
E       AssertionError: expected call not found.
E       Expected: print('[yellow]File mismatch.json has totalResults=10 but contains 1 vulnerabilities. Flagging for re-download.[/yellow]')
E         Actual: print('[yellow]File mismatch.json has mismatched counts. Flagging for re-download.[/yellow]')
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('[yellow]Fil...d.[/yellow]',) == ('[yellow]Fil...d.[/yellow]',)
E         
E         At index 0 diff: '[yellow]File mismatch.json has mismatched counts. Flagging for re-download.[/yellow]' != '[yellow]File mismatch.json has totalResults=10 but contains 1 vulnerabilities. Flagging for re-download.[/yellow]'
E         Use -v to get more diff

tests/test_cve_download_update.py:207: AssertionError
_______________________ test_is_error_file_empty_results _______________________

self = <MagicMock name='print' id='127019400579312'>

    def assert_not_called(self):
        """assert that the mock was never called.
        """
        if self.call_count != 0:
            msg = ("Expected '%s' to not have been called. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'print' to not have been called. Called 1 times.
E           Calls: [call("[yellow]File empty.json has download status 'unknown'. Flagging for re-download.[/yellow]")].

/usr/lib/python3.12/unittest/mock.py:905: AssertionError

During handling of the above exception, another exception occurred:

mocker = <pytest_mock.plugin.MockerFixture object at 0x738602083740>

    def test_is_error_file_empty_results(mocker):
        """Test is_error_file with totalResults 0 and empty vulnerabilities."""
        mock_open = mocker.patch("builtins.open", mocker.mock_open(read_data=json.dumps({"totalResults": 0, "vulnerabilities": []})))
        mock_print = mocker.patch("wafrunner_cli.commands.cve.print")
        assert is_error_file(Path("empty.json")) is True
        # No warning for this specific case, as it's a valid "no results" scenario that still needs re-checking
>       mock_print.assert_not_called()
E       AssertionError: Expected 'print' to not have been called. Called 1 times.
E       Calls: [call("[yellow]File empty.json has download status 'unknown'. Flagging for re-download.[/yellow]")].
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('[yellow]Fil...d.[/yellow]',) == ()
E         
E         Left contains one more item: "[yellow]File empty.json has download status 'unknown'. Flagging for re-download.[/yellow]"
E         Use -v to get more diff

tests/test_cve_download_update.py:217: AssertionError
______________________ test_upload_api_error_not_tracked _______________________

self = <MagicMock name='mock.post' id='127019396251920'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'post' to have been called once. Called 3 times.
E           Calls: [call('/vulnerability_records', json={'cveID': 'CVE-2024-0007', 'name': 'Vulnerability CVE-2024-0007', 'description': 'Description for CVE-2024-0007', 'mitigation': 'No mitigation available.', 'last_updated_date': '2024-01-01', 'published_date': '', 'nist_base_score': 0.0, 'cweIDs': ['N/A'], 'tags': ['Auto-Generated'], 'affected_systems': ['Unknown'], 'raw_data': {'cve': {'id': 'CVE-2024-0007', 'lastModified': '2024-01-01T00:00:00.000Z', 'descriptions': [{'lang': 'en', 'value': 'Description for CVE-2024-0007'}], 'weaknesses': [], 'metrics': {}}}}),
E            call('/vulnerability_records', json={'cveID': 'CVE-2024-0007', 'name': 'Vulnerability CVE-2024-0007', 'description': 'Description for CVE-2024-0007', 'mitigation': 'No mitigation available.', 'last_updated_date': '2024-01-01', 'published_date': '', 'nist_base_score': 0.0, 'cweIDs': ['N/A'], 'tags': ['Auto-Generated'], 'affected_systems': ['Unknown'], 'raw_data': {'cve': {'id': 'CVE-2024-0007', 'lastModified': '2024-01-01T00:00:00.000Z', 'descriptions': [{'lang': 'en', 'value': 'Description for CVE-2024-0007'}], 'weaknesses': [], 'metrics': {}}}}),
E            call('/vulnerability_records', json={'cveID': 'CVE-2024-0007', 'name': 'Vulnerability CVE-2024-0007', 'description': 'Description for CVE-2024-0007', 'mitigation': 'No mitigation available.', 'last_updated_date': '2024-01-01', 'published_date': '', 'nist_base_score': 0.0, 'cweIDs': ['N/A'], 'tags': ['Auto-Generated'], 'affected_systems': ['Unknown'], 'raw_data': {'cve': {'id': 'CVE-2024-0007', 'lastModified': '2024-01-01T00:00:00.000Z', 'descriptions': [{'lang': 'en', 'value': 'Description for CVE-2024-0007'}], 'weaknesses': [], 'metrics': {}}}}),
E            call().raise_for_status()].

/usr/lib/python3.12/unittest/mock.py:923: AssertionError

During handling of the above exception, another exception occurred:

cve_input_dir = PosixPath('/tmp/pytest-of-sam/pytest-61/test_upload_api_error_not_trac0/cve-sources')
mock_api_client = <MagicMock id='127019396224240'>
mock_tracking_io = (<MagicMock name='load_uploaded_cves_tracking' id='127019396237552'>, <MagicMock name='save_uploaded_cves_tracking' id='127019396311680'>)
mock_time_sleep = <MagicMock name='sleep' id='127019396307360'>

    def test_upload_api_error_not_tracked(cve_input_dir, mock_api_client, mock_tracking_io, mock_time_sleep): # Removed mock_transform_vulnerability
        cve_id = "CVE-2024-0007"
        last_modified = "2024-01-01T00:00:00.000Z"
        mock_load, mock_save = mock_tracking_io
        create_mock_cve_file(cve_input_dir, "cve7.json", [{"id": cve_id, "lastModified": last_modified}])
    
        mock_api_client.get.return_value = MagicMock(status_code=404) # CVE not found
        mock_api_client.post.return_value = MagicMock(status_code=500, text="Internal Server Error") # API error
    
        result = runner.invoke(cve_app, ["upload", "--input-dir", str(cve_input_dir)])
    
        assert result.exit_code == 0
        assert "Errors" in result.stdout # Check for total errors
        assert "1" in result.stdout # Check for total errors count
        assert "Error Create Failed" in result.stdout # Check for specific error count
>       mock_api_client.post.assert_called_once()
E       AssertionError: Expected 'post' to have been called once. Called 3 times.
E       Calls: [call('/vulnerability_records', json={'cveID': 'CVE-2024-0007', 'name': 'Vulnerability CVE-2024-0007', 'description': 'Description for CVE-2024-0007', 'mitigation': 'No mitigation available.', 'last_updated_date': '2024-01-01', 'published_date': '', 'nist_base_score': 0.0, 'cweIDs': ['N/A'], 'tags': ['Auto-Generated'], 'affected_systems': ['Unknown'], 'raw_data': {'cve': {'id': 'CVE-2024-0007', 'lastModified': '2024-01-01T00:00:00.000Z', 'descriptions': [{'lang': 'en', 'value': 'Description for CVE-2024-0007'}], 'weaknesses': [], 'metrics': {}}}}),
E        call('/vulnerability_records', json={'cveID': 'CVE-2024-0007', 'name': 'Vulnerability CVE-2024-0007', 'description': 'Description for CVE-2024-0007', 'mitigation': 'No mitigation available.', 'last_updated_date': '2024-01-01', 'published_date': '', 'nist_base_score': 0.0, 'cweIDs': ['N/A'], 'tags': ['Auto-Generated'], 'affected_systems': ['Unknown'], 'raw_data': {'cve': {'id': 'CVE-2024-0007', 'lastModified': '2024-01-01T00:00:00.000Z', 'descriptions': [{'lang': 'en', 'value': 'Description for CVE-2024-0007'}], 'weaknesses': [], 'metrics': {}}}}),
E        call('/vulnerability_records', json={'cveID': 'CVE-2024-0007', 'name': 'Vulnerability CVE-2024-0007', 'description': 'Description for CVE-2024-0007', 'mitigation': 'No mitigation available.', 'last_updated_date': '2024-01-01', 'published_date': '', 'nist_base_score': 0.0, 'cweIDs': ['N/A'], 'tags': ['Auto-Generated'], 'affected_systems': ['Unknown'], 'raw_data': {'cve': {'id': 'CVE-2024-0007', 'lastModified': '2024-01-01T00:00:00.000Z', 'descriptions': [{'lang': 'en', 'value': 'Description for CVE-2024-0007'}], 'weaknesses': [], 'metrics': {}}}}),
E        call().raise_for_status()].
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('/vulnerability_records',) == ()
E         
E         Left contains one more item: '/vulnerability_records'
E         Use -v to get more diff
E       Kwargs:
E       assert {'json': {'af...4-0007', ...}} == {}
E         
E         Left contains 1 more item:
E         {'json': {'affected_systems': ['Unknown'],
E                   'cveID': 'CVE-2024-0007',
E                   'cweIDs': ['N/A'],
E                   'description': 'Description for CVE-2024-0007',
E                   'last_updated_date': '2024-01-01',...
E         
E         ...Full output truncated (13 lines hidden), use '-vv' to show

tests/test_cve_upload_tracking.py:222: AssertionError
______________________ test_upload_skipped_missing_cveid _______________________

cve_input_dir = PosixPath('/tmp/pytest-of-sam/pytest-61/test_upload_skipped_missing_cv0/cve-sources')
mock_api_client = <MagicMock id='127019397667376'>
mock_tracking_io = (<MagicMock name='load_uploaded_cves_tracking' id='127019397517280'>, <MagicMock name='save_uploaded_cves_tracking' id='127019395702064'>)
mock_time_sleep = <MagicMock name='sleep' id='127019395622640'>

    def test_upload_skipped_missing_cveid(cve_input_dir, mock_api_client, mock_tracking_io, mock_time_sleep): # Removed mock_transform_vulnerability
        # Create a mock CVE file with a record missing the 'id' field
        mock_load, mock_save = mock_tracking_io
        create_mock_cve_file(cve_input_dir, "cve_missing_id.json", [{"lastModified": "2024-01-01T00:00:00.000Z"}])
    
        result = runner.invoke(cve_app, ["upload", "--input-dir", str(cve_input_dir)])
    
        assert result.exit_code == 0
>       assert "Skipped (No CVE ID)" in result.stdout # Check for the outcome string
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert 'Skipped (No CVE ID)' in 'Starting CVE upload from \n/tmp/pytest-of-sam/pytest-61/test_upload_skipped_missing_cv0/cve-sources...\nReading, pars...ct)              │     0 │\n│ Total Errors                    │     0 │\n└─────────────────────────────────┴───────┘\n'
E        +  where 'Starting CVE upload from \n/tmp/pytest-of-sam/pytest-61/test_upload_skipped_missing_cv0/cve-sources...\nReading, pars...ct)              │     0 │\n│ Total Errors                    │     0 │\n└─────────────────────────────────┴───────┘\n' = <Result okay>.stdout

tests/test_cve_upload_tracking.py:234: AssertionError
___________________ test_github_command_no_identifier_fails ____________________

    def test_github_command_no_identifier_fails():
        """Test that the command exits with an error if no identifier is provided."""
        result = runner.invoke(research_app, ["github"])
        assert result.exit_code == 1
>       assert "Error: Please provide either a --collection or a --vulnid." in result.stdout
E       AssertionError: assert 'Error: Please provide either a --collection or a --vulnid.' in ''
E        +  where '' = <Result SystemExit(1)>.stdout

tests/test_research_commands.py:34: AssertionError
__________________ test_github_command_both_identifiers_fail ___________________

    def test_github_command_both_identifiers_fail():
        """Test that the command exits with an error if both identifiers are provided."""
        result = runner.invoke(research_app, ["github", "--collection", "my-coll", "--vulnid", "VULN-123"])
        assert result.exit_code == 1
>       assert "Error: Options --collection and --vulnid are mutually exclusive." in result.stdout
E       AssertionError: assert 'Error: Options --collection and --vulnid are mutually exclusive.' in ''
E        +  where '' = <Result SystemExit(1)>.stdout

tests/test_research_commands.py:40: AssertionError
___________________ test_github_command_with_vulnid_succeeds ___________________

mock_api_client = <MagicMock id='127019396899104'>
mock_config_manager = <MagicMock id='127019397591072'>

    def test_github_command_with_vulnid_succeeds(mock_api_client, mock_config_manager):
        """Test a successful run with a single vulnID."""
        result = runner.invoke(research_app, ["github", "--vulnid", "VULN-123"])
        assert result.exit_code == 0
>       assert "Found 1 vulnerability ID(s) to process." in result.stdout
E       AssertionError: assert 'Found 1 vulnerability ID(s) to process.' in ''
E        +  where '' = <Result okay>.stdout

tests/test_research_commands.py:46: AssertionError
_________________ test_github_command_with_collection_succeeds _________________

mock_api_client = <MagicMock id='127019397368576'>
mock_config_manager = <MagicMock id='127019397280496'>
tmp_path = PosixPath('/tmp/pytest-of-sam/pytest-61/test_github_command_with_colle0')

    def test_github_command_with_collection_succeeds(mock_api_client, mock_config_manager, tmp_path):
        """Test a successful run with a collection file."""
        # Create a mock collection file
        collection_file = tmp_path / "my-collection.txt"
        collection_file.write_text("VULN-001\nVULN-002")
    
        result = runner.invoke(research_app, ["github", "--collection", "my-collection.txt"])
    
        assert result.exit_code == 0
>       assert "Found 2 vulnerability ID(s) to process." in result.stdout
E       AssertionError: assert 'Found 2 vulnerability ID(s) to process.' in ''
E        +  where '' = <Result okay>.stdout

tests/test_research_commands.py:60: AssertionError
___________________ test_github_command_collection_not_found ___________________

mock_config_manager = <MagicMock id='127019397410224'>

    def test_github_command_collection_not_found(mock_config_manager):
        """Test that the command exits if the collection file is not found."""
        result = runner.invoke(research_app, ["github", "--collection", "non-existent-collection"])
        assert result.exit_code == 1
>       assert "Error: Collection 'non-existent-collection' not found" in result.stdout
E       assert "Error: Collection 'non-existent-collection' not found" in ''
E        +  where '' = <Result SystemExit(1)>.stdout

tests/test_research_commands.py:69: AssertionError
=========================== short test summary info ============================
FAILED tests/test_collection_commands.py::test_collection_list - AssertionErr...
FAILED tests/test_cve_download_update.py::test_download_no_update_file_exists_valid
FAILED tests/test_cve_download_update.py::test_download_no_update_file_exists_invalid
FAILED tests/test_cve_download_update.py::test_download_update_file_exists_valid
FAILED tests/test_cve_download_update.py::test_is_error_file_total_mismatch
FAILED tests/test_cve_download_update.py::test_is_error_file_empty_results - ...
FAILED tests/test_cve_upload_tracking.py::test_upload_api_error_not_tracked
FAILED tests/test_cve_upload_tracking.py::test_upload_skipped_missing_cveid
FAILED tests/test_research_commands.py::test_github_command_no_identifier_fails
FAILED tests/test_research_commands.py::test_github_command_both_identifiers_fail
FAILED tests/test_research_commands.py::test_github_command_with_vulnid_succeeds
FAILED tests/test_research_commands.py::test_github_command_with_collection_succeeds
FAILED tests/test_research_commands.py::test_github_command_collection_not_found
======================== 13 failed, 46 passed in 0.72s =========================
